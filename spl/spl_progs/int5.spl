alias phySP S0;
phySP = ([PTBR + 2 * (SP / 512)] * 512) + (SP % 512);//calculate physical address of the stack pointer

alias sysCallNo S1;
sysCallNo = [phySP - 1];        //find syscall number
if( sysCallNo == 8)then
    alias i S2;

    /////// Search the Ready List for a free process /////////////////
    i = 1;
    while (i < 32) do
    	  if([READY_LIST + 32 * i + 1] == 0)then
	  	break;
	  endif;
	  i = i + 1;
    endwhile;
    //////////////////////////////////////////////////////////////

    //// if not found return -1
    if (i == 32)then
       [phySP - 2] = -1;
       ireturn;
    endif;

    alias newpcb S3;
    newpcb = i;

    [READY_LIST + 32 * newpcb] = newpcb;	// Set PID of the new process to the PCB index

    ///// find a free page for the stack of new process
    
    i = 24;
    while( i < 64)do
    	   if([MEM_LIST + i] == 0)then
	   	break;
	   endif;
	   i = i + 1;
    endwhile;
    ///////////////////////////////////////////////////////////////////
    
    /// if not found return -1
    if (i == 64)then
       [phySP - 2] = -1;
       ireturn;
    endif;

    //////// Allocate the page for the child process //////////////////
    
    [MEM_LIST + i] = 1; //mark page as USED


    // copy the contents from the current process' page to new allocated page
    alias counter S5;
    alias origpage S6;
    counter = 0;
    origpage = [PTBR + 3 * 2];
    while( counter < 512) do
         [i * 512 + counter] = [origpage * 512 + counter];
         counter = counter + 1;
    endwhile;

    alias childpt S4;
    childpt = PAGE_TABLE + newpcb * 8;   // find pagetable of child process
    [childpt + 3 * 2] = i ;	
    [childpt + 3 * 2 + 1 ] = "01";

    ///////////////////////////////////////////////////////////////////

    /// Copy the pagetable entries of the cuurent process to child and increment share count
    counter = 0;
    while ( counter < 3)do
    	[childpt + counter * 2] = [PTBR + counter * 2 ];
	[childpt + counter * 2 + 1 ] = [PTBR + counter * 2 + 1];

	if [childpt + counter * 2 + 1] == "01" || [childpt + counter * 2 + 1] == "11" then
	     alias page S6;
	     page = [childpt + counter * 2];
	     [MEM_LIST + page] = [MEM_LIST + page] + 1;	//increment memory page share count
	else
	     alias page S6;
	     page = [childpt + counter * 2];
	     if (page >= 448) then
	         [DISK_LIST + page] = [DISK_LIST + page] + 1;	// increment disk block share count
	     endif;
	endif;
	counter = counter + 1;
    endwhile;
    store (6, 20);

     [READY_LIST + newpcb * 32 + 6 ] = PTLR;	// copy PTLR to child PCB
     [READY_LIST + newpcb * 32 + 5 ] = childpt;	// set PTBR of child process
     [READY_LIST + newpcb * 32 + 4 ] = [phySP];	// copy the IP to child process' PCB
     [READY_LIST + newpcb * 32 + 3 ] = SP - 1;  // copy stack pointer. SP - 1 because IP is on top of the stack now
     [READY_LIST + newpcb * 32 + 2 ] = BP; // copy BP to child's PCB

     ///// Copy the values of registers to PCB
     [READY_LIST + newpcb * 32 + 7] = R0;
     [READY_LIST + newpcb * 32 + 8] = R1;
     [READY_LIST + newpcb * 32 + 9] = R2;
     [READY_LIST + newpcb * 32 + 10] = R3;
     [READY_LIST + newpcb * 32 + 11] = R4;
     [READY_LIST + newpcb * 32 + 12] = R5;
     [READY_LIST + newpcb * 32 + 13] = R6;
     [READY_LIST + newpcb * 32 + 14] = R7;
     //////////////////////////////////
     
     i = 0;
     alias curpcb S5;
     curpcb = READY_LIST + ((PTBR - 1024)/8) * 32;
     alias swofte S4;

     ///// Copy the per process file table to new process' PCB
     while (i < 8)do
     	   swofte = [curpcb + 15 + i * 2];

	   ////// Set PCB entries for open file 'i'
	   [READY_LIST + newpcb * 32 + 15 + i * 2] = swofte;	
	   [READY_LIST + newpcb * 32 + 15 + i * 2 + 1] = [curpcb + 15 + i * 2 + 1];
	   
     	   if (swofte != -1)then
	       [FILE_TABLE + swofte * 2] = [FILE_TABLE + swofte * 2] + 1;  // increment the file open count in the system eide open file table
	   endif;
	   
     	   i = i + 1;
     endwhile;

     [READY_LIST + newpcb * 32 + 31] = (PTBR - 1024)/8;  // Set process id of parent as pid of current process in child process' PCB

     [READY_LIST + newpcb * 32 + 1] = 1;	// set the state of child process to READY
     [ phySP - 2] = newpcb; // set return value of current process as PID of child

     alias ptbr_child S2;
     ptbr_child = [READY_LIST + 32 * newpcb + 5];

     [[ptbr_child + 3 * 2] * 512 + ((SP - 1) % 512) - 1] = -2;	// Set the return value of child process as -2
     ireturn;     
     
endif;