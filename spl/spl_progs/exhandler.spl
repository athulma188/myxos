alias cause S0;
alias vpagenum S1;
alias ip_addr S2;

cause = EFR % 10;
vpagenum = (EFR / 10) % 100;
ip_addr = (EFR / 1000);

alias phySP S7;
phySP = [PTBR + 2 * (SP /512)] * 512 + (SP%512);

if (cause == 0) then //if page fault
     if (vpagenum == -1) then
     	[phySP - 1] = 10; // syscall no = 10
     	inline "JMP 11776";	// jump to exit system call code
     endif;

     ///// Search for a free page
     alias counter S3;
     counter = 24;
     while (counter < 64) do
     	   if ([MEM_LIST + counter ] == 0) then
	      [MEM_LIST + counter] = 1;
	      break;
	   endif;
	   counter = counter + 1;
     endwhile;
     ////////////////////

     alias freepage S4;
     if (counter != 64) then	//if found allocate
     	freepage = counter;
     else	 //else replace a existing page

	alias pgno S5;
	alias flag S6;
	alias curpid S7;
	curpid = ((PTBR - 1024)/8);
	pgno = vpagenum;
	flag = 0;
	while (flag == 0) do	// do until a victim page is found
	      if (curpid == 32)then
	      	 curpid = 0;
	      endif;
	      
	      
	      while (pgno < 3)do
	      	    if ([PAGE_TABLE + curpid * 8 + pgno * 2 + 1]%10 == 1) then
		    
			if ([PAGE_TABLE + curpid * 8 + pgno * 2 + 1]/10 == 1) then
		       	   [PAGE_TABLE + curpid * 8 + pgno * 2 + 1] = "01"; //change refernce bit to 1
		        else if ([PAGE_TABLE + curpid * 8 + pgno * 2 + 1]/10 == 0)then
			
		       	   	if ([MEM_LIST + [PAGE_TABLE + curpid * 8 + pgno * 2]] > 1) then //ignore if it is a shared page
				   pgno = pgno + 1;
		           	   continue;
		    	      	   endif;
			
				flag = 1;	// else set flag = 1
		        	freepage = [PAGE_TABLE + curpid * 8 + pgno * 2]; 
					
				///search for a page to  store the victim page to swap area
				counter = 448;
				while (counter < 512) do
			     	      if ([DISK_LIST + counter] == 0)then
			      	      break;
			      	      endif;
			      	      counter = counter + 1;
				endwhile;
			
				if (counter == 512) then	//if no free swap block found exit
			   	   inline "JMP 11776";
				endif;

				store (freepage, counter);	//store victim page to swap

				[DISK_LIST + counter] = 1;	// increment sharecount
				store (6, 20);	      // store disk free list

				[PAGE_TABLE + curpid * 8 + pgno * 2] = counter;	// set the page table entry of victim 
				[PAGE_TABLE + curpid * 8 + pgno * 2 + 1] = "00";
			
				break;
		    	endif;
			endif;
		     endif;
		     pgno = pgno + 1;
	      endwhile;
	      pgno = 0;
	      curpid = curpid + 1;
	endwhile;
     
     endif;

     alias phyPgno S6;
     phyPgno = [ PTBR + vpagenum * 2];	// find phy page no of page that caused page fault
     if (phyPgno >= 21 && phyPgno <= 447) then	//if it is a disk block load it to found page
     	load (freepage, phyPgno);
     else if ( phyPgno >= 448 && phyPgno <= 511) then	// if it is swap block load it and decrement the share count
     	load (freepage,phyPgno);
	[DISK_LIST + phyPgno] = [DISK_LIST + phyPgno] - 1;
	store(6,20); //store diskfree list to disk
     endif;
     endif;

     [PTBR + vpagenum * 2] = freepage;	//set pagetable of current process' page to allocated page 
     [PTBR + vpagenum * 2 + 1] = "11"; //set reference bit to 1

     SP = SP + 1;

     alias phySP S6;
     phySP = [PTBR + 2 * (SP / 512)] * 512 + (SP % 512);
     [phySP] = ip_addr; // push ip to stack top
     ireturn;     

else if (cause == 1) then 
     print "Illegal instruction";
     [phySP - 1] = 10;
     inline "JMP 11776" ;
     
else if (cause == 2) then
     print "Illegal memory access";
     [phySP - 1] = 10; 
     inline "JMP 11776";
     
else if (cause == 3) then
     print "Arithmetic exception";
     [phySP - 1] = 10;     
     inline "JMP 11776";
     
else if (cause == 4) then
     print "Illegal operands";
     [phySP - 1] = 10;     
     inline "JMP 11776";
endif;
endif;
endif;
endif;
endif;
